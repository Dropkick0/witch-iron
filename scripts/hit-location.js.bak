/**
 * Hit Location Selection Module for Witch Iron
 */
export class HitLocationSelector {
    /**
     * Opens the hit location selector dialog
     * @param {object} data Data for the dialog
     * @static
     */
    static async openDialog(data) {
        console.log("Opening hit location selector dialog with data:", data);
        
        // Ensure we have valid input data
        if (!data) data = {};
        
        // Create dialog data
            const dialogData = {
            attacker: data.attacker,
            defender: data.defender,
                damageAmount: data.damage || 0,
            defenderName: data.defender || "Target",
                netHits: data.netHits || 0,
            remainingHits: data.netHits || 0,
                autoApply: true,
                applyHitCallback: (location, remainingHits) => {
                    // Apply the hit with the selected location and remaining hits
                    this._applyHit(data.attacker, data.defender, data.damage, location, data.messageId, remainingHits);
            }
        };
        
        // Get battle wear data if we have attacker and defender names
        if (data.attacker && data.defender) {
            dialogData.battleWear = await this._getBattleWearData(data.attacker, data.defender);
        }
        
        // Create and render a new dialog
        const dialog = new HitLocationDialog(dialogData);
            dialog.render(true);
    }
    
    /**
     * Apply the hit to the selected location
     * @param {string} attacker Name of the attacker
     * @param {string} defender Name of the defender
     * @param {number} damage Amount of damage to apply
     * @param {string} location Hit location
     * @param {string} messageId ID of the combat message
     * @param {number} remainingHits Net hits remaining after location adjustments
     * @private
     */
    static async _applyHit(attacker, defender, damage, location, messageId, remainingHits) {
        // Normalize location to capitalize first letter of each word for display
        const displayLocation = location.split('-').map(word => 
            word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
        
        // Find the defender actor
        let defenderActor = null;
        
        // First look in tokens
        for (const token of canvas.tokens.placeables) {
            if (token.name === defender && token.actor) {
                defenderActor = token.actor;
                break;
            }
        }
        
        // If not found in tokens, look in actors directory
        if (!defenderActor) {
            defenderActor = game.actors.find(a => a.name === defender);
        }
        
        // Get the original message for combat data
        const originalMessage = game.messages.get(messageId);
        let soak = 0;
        let weaponDmg = 0;
        let netHits = 0;
        let locationRoll = 0;
        let recalculatedDamage = damage; // Default to original damage
        
        if (originalMessage) {
            const injuryData = originalMessage.getFlag("witch-iron", "injuryData") || 
                              (originalMessage.content && 
                               $(originalMessage.content).find('.debug-info').length && 
                               this._parseDebugInfo($(originalMessage.content).find('.debug-info').html()));
            
            if (injuryData) {
                soak = injuryData.soak || 0;
                weaponDmg = injuryData.weaponDmg || 0;
                // Use the remaining hits instead of the original net hits if available
                netHits = (remainingHits !== undefined) ? remainingHits : (injuryData.netHits || 0);
                locationRoll = injuryData.locationRoll || 0;
                
                // Recalculate damage using the remaining net hits
                // Formula: (Net Hits + Weapon Damage) - Soak = Net Damage
                recalculatedDamage = Math.max(0, (netHits + weaponDmg) - soak);
                
                console.log(`Recalculated damage: (${netHits} net hits + ${weaponDmg} weapon) - ${soak} soak = ${recalculatedDamage} damage`);
            }
        }
        
        // Create a combined combat data object
        const combatData = {
            attacker: attacker,
            defender: defender,
            location: displayLocation,
            severity: recalculatedDamage,
            recalculatedDamage: recalculatedDamage,
            weapon: weaponDmg > 0 ? `${weaponDmg}` : "-",
            weaponDmg: weaponDmg,
            soak: soak,
            netHits: netHits,
            locationRoll: locationRoll,
            messageId: messageId,
            isDeflected: recalculatedDamage === 0,
            remainingNetHits: remainingHits || 0
        };
        
        // Create the injury chat message
        await this._createInjuryMessage(combatData);
        
        // If damage > 0 and we found the defender actor, create an actual injury item on them
        if (recalculatedDamage > 0 && defenderActor && game.user.isGM) {
            // Generate a simple injury name based on location and recalculated damage
            let injurySeverity = "Minor";
            if (recalculatedDamage >= 7) {
                injurySeverity = "Severe";
            } else if (recalculatedDamage >= 4) {
                injurySeverity = "Major";
            }
            
            const injuryName = `${injurySeverity} ${displayLocation} Injury`;
            const injuryEffect = this._generateInjuryEffect(location, recalculatedDamage);
            
            // Create the injury item on the defender
            await this._createInjuryItem(defenderActor, injuryName, displayLocation, recalculatedDamage, injuryEffect);
        }
    }
    
    /**
     * Parse debug info from the message HTML
     * @param {string} debugHtml Debug info HTML
     * @returns {Object} Parsed injury data
     * @private
     */
    static _parseDebugInfo(debugHtml) {
        const data = {};
        const lines = debugHtml.split("\n");
        
        lines.forEach(line => {
            const match = line.match(/<div>([^:]+):\s*([^<]+)<\/div>/);
            if (match) {
                const key = match[1];
                const value = match[2].trim();
                
                if (key === "soak" || key === "weaponDmg" || key === "netHits" || key === "netDamage" || key === "locationRoll") {
                    data[key] = parseInt(value) || 0;
                } else {
                    data[key] = value;
                }
            }
        });
        
        return data;
    }
    
    /**
     * Generate an injury effect description based on location and damage
     * @param {string} location Hit location
     * @param {number} damage Amount of damage
     * @returns {string} Effect description
     * @private
     */
    static _generateInjuryEffect(location, damage) {
        // Normalize location to capitalize first letter of each word
        const normalizedLocation = location.split('-').map(word => 
            word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
        
        // Generic injury effects based on severity and location
        const lowEffect = "Pain 1";
        const medEffect = "Pain 2";
        const highEffect = "Trauma 2";
        
        let effect = "";
        
        // Determine effect based on location and damage
        if (normalizedLocation === "Head") {
            if (damage >= 7) {
                effect = "Concussion, Stun 3";
            } else if (damage >= 4) {
                effect = "Disoriented, Stun 2";
            } else {
                effect = "Mild Pain, Stun 1";
            }
        } else if (normalizedLocation === "Torso") {
            if (damage >= 7) {
                effect = "Internal Damage, Bleed 3";
            } else if (damage >= 4) {
                effect = "Winded, Stun 2";
            } else {
                effect = "Bruised Ribs, Pain 1";
            }
        } else if (normalizedLocation.includes("Arm")) {
            if (damage >= 7) {
                effect = "Broken, Useless Arm, Trauma 3";
            } else if (damage >= 4) {
                effect = "Damaged Muscle, Half Effectiveness, Pain 2";
            } else {
                effect = "Bruised Arm, Pain 1";
            }
        } else if (normalizedLocation.includes("Leg")) {
            if (damage >= 7) {
                effect = "Broken, Can't Stand, Trauma 3";
            } else if (damage >= 4) {
                effect = "Hampered Movement, Half Speed, Pain 2";
            } else {
                effect = "Bruised Leg, Pain 1";
            }
        }
        
        return effect;
    }
    
    /**
     * Create an injury message in chat
     * @param {object} combatData The combat data including attacker, defender, location, etc.
     * @private
     */
    static async _createInjuryMessage(combatData) {
        // Roll a random severity if not provided
        if (!combatData.severity) {
            combatData.severity = Math.floor(Math.random() * 10) + 1;
        }
        
        // If the severity has been recomputed, use that
        if (combatData.recalculatedDamage !== undefined) {
            combatData.severity = combatData.recalculatedDamage;
        }
        
        // Generate a description for the injury based on location and severity
        combatData.description = this._generateInjuryDescription(combatData.location, combatData.severity);
        
        // Generate an effect for the injury based on location and severity
        combatData.effect = HitLocationSelector._generateInjuryEffect(combatData.location.toLowerCase().replace(' ', '-'), combatData.severity);
        
        // Get battle wear data from attacker and defender
        const battleWearData = await this._getBattleWearData(combatData.attacker, combatData.defender);
        
        // Find attacker and defender actors to get their ability bonus and equipment values
        let attackerActor = null;
        let defenderActor = null;
        
        // Search in tokens first
        for (const token of canvas.tokens.placeables) {
            if (token.name === combatData.attacker && token.actor) {
                attackerActor = token.actor;
            }
            if (token.name === combatData.defender && token.actor) {
                defenderActor = token.actor;
            }
            
            if (attackerActor && defenderActor) break;
        }
        
        // If not found in tokens, look in actors directory
        if (!attackerActor) {
            attackerActor = game.actors.find(a => a.name === combatData.attacker);
        }
        if (!defenderActor) {
            defenderActor = game.actors.find(a => a.name === combatData.defender);
        }
        
        // Define the weapon and armor bonus tables
        const weaponBonusTable = {
            "unarmed": 2,
            "light": 4,
            "medium": 6,
            "heavy": 8,
            "superheavy": 10
        };

        const armorBonusTable = {
            "none": 0,
            "light": 2,
            "medium": 4,
            "heavy": 6,
            "superheavy": 8
        };
        
        // Get ability bonus and equipment values
        let attackerAbilityBonus = 3;
        let defenderAbilityBonus = 3;
        let weaponBonus = 4; // Default to light weapon
        let armorBonus = 0;  // Default to no armor
        
        if (attackerActor) {
            // Get ability bonus from attacker
            attackerAbilityBonus = attackerActor.system?.derived?.abilityBonus || 3;
            
            // Get weapon type and bonus
            const weaponType = attackerActor.system?.weaponType?.value || "light";
            weaponBonus = weaponBonusTable[weaponType] || 4;
            
            console.log(`Attacker ${combatData.attacker} - Ability: ${attackerAbilityBonus}, Weapon Type: ${weaponType}, Weapon Bonus: ${weaponBonus}`);
        }
        
        if (defenderActor) {
            // Get ability bonus from defender
            defenderAbilityBonus = defenderActor.system?.derived?.abilityBonus || 3;
            
            // Get armor type and bonus
            const armorType = defenderActor.system?.armorType?.value || "none";
            armorBonus = armorBonusTable[armorType] || 0;
            
            console.log(`Defender ${combatData.defender} - Ability: ${defenderAbilityBonus}, Armor Type: ${armorType}, Armor Bonus: ${armorBonus}`);
        }
        
        // Format the display text for damage and soak
        const abilityWeaponText = `${attackerAbilityBonus}(${weaponBonus})`;
        const abilitySoakText = `${defenderAbilityBonus}(${armorBonus})`;
        
        // Set the flavor text and message type based on whether the attack was deflected
        const flavor = combatData.isDeflected ? "Attack Deflected" : "Combat Injury";
        const messageType = combatData.isDeflected ? "deflection" : "injury";
        
        // Render the template and create the chat message
        const content = await renderTemplate("systems/witch-iron/templates/chat/injury-message.hbs", {
            attacker: combatData.attacker,
            defender: combatData.defender,
            location: combatData.location,
            severity: combatData.severity,
            damage: combatData.severity,
            weapon: combatData.weapon || "-",
            soak: combatData.soak || 0,
            netHits: combatData.netHits || 0,
            description: combatData.description,
            effect: combatData.effect,
            isDeflected: combatData.isDeflected || false,
            battleWear: battleWearData,
            // Add new values
            abilityBonus: attackerAbilityBonus,
            weaponBonus: weaponBonus,
            armorBonus: armorBonus,
            abilityWeaponText: abilityWeaponText,
            abilitySoakText: abilitySoakText
        });
        
        // Create the chat message
        ChatMessage.create({
            user: game.user.id,
            content: content,
            speaker: ChatMessage.getSpeaker(),
            flavor: flavor,
            flags: {
                "witch-iron": {
                    messageType: messageType
                }
            }
        });
    }
    
    /**
     * Get battle wear data for attacker and defender
     * @param {string} attackerName Name of the attacker
     * @param {string} defenderName Name of the defender
     * @returns {object} Object containing battle wear data
     * @private
     */
    static async _getBattleWearData(attackerName, defenderName) {
        // Find attacker and defender actors
        let attackerActor = null;
        let defenderActor = null;
        
        // Search in tokens first
        for (const token of canvas.tokens.placeables) {
            if (token.name === attackerName && token.actor) {
                attackerActor = token.actor;
            }
            if (token.name === defenderName && token.actor) {
                defenderActor = token.actor;
            }
            
            // If we found both, stop searching
            if (attackerActor && defenderActor) break;
        }
        
        // If not found in tokens, look in actors directory
        if (!attackerActor) {
            attackerActor = game.actors.find(a => a.name === attackerName);
        }
        if (!defenderActor) {
            defenderActor = game.actors.find(a => a.name === defenderName);
        }
        
        // Default battle wear data
        const battleWearData = {
            attacker: {
                maxWear: 4,
                weaponBonus: 0,
                currentWear: 0,
                tokenImg: "icons/svg/mystery-man.svg"
            },
            defender: {
                maxWear: 4,
                armorBonus: 0,
                currentWear: 0,
                tokenImg: "icons/svg/mystery-man.svg"
            }
        };
        
        // If we found the attacker, get their weapon bonus and token image
        if (attackerActor) {
            // Get weapon bonus and battle wear from the actor's derived data
            if (attackerActor.system?.derived) {
                const actorWeaponWear = attackerActor.system.battleWear?.weapon?.value || 0;
                const actorWeaponMax = attackerActor.system.derived.weaponBonusMax || 4;
                
                // Display max wear as the weapon bonus max - current wear
                // For injury card, we want to start at 0 and subtract from max
                battleWearData.attacker.maxWear = Math.max(0, actorWeaponMax - actorWeaponWear);
                battleWearData.attacker.weaponBonus = attackerActor.system.derived.weaponBonusEffective || 0;
                battleWearData.attacker.currentWear = 0; // Start at 0 for the injury card
                battleWearData.attacker.actualWear = actorWeaponWear; // Store the actual wear for reference
            } else {
                // Fallback to finding the actor's equipped weapon
            const equippedWeapon = attackerActor.items.find(i => 
                i.type === "weapon" && 
                i.system.equipped
            );
            
            if (equippedWeapon) {
                // Get the weapon's damage bonus as max wear
                    const weaponBonus = parseInt(equippedWeapon.system.damage.bonus) || 4;
                    battleWearData.attacker.maxWear = weaponBonus;
                    battleWearData.attacker.weaponBonus = weaponBonus;
                battleWearData.attacker.weaponName = equippedWeapon.name;
                }
            }
            
            // Get token image
            if (attackerActor.token) {
                battleWearData.attacker.tokenImg = attackerActor.token.img;
            } else if (attackerActor.prototypeToken) {
                battleWearData.attacker.tokenImg = attackerActor.prototypeToken.texture.src;
            } else {
                battleWearData.attacker.tokenImg = attackerActor.img;
            }
        }
        
        // If we found the defender, get their armor bonus and token image
        if (defenderActor) {
            // Get armor bonus and battle wear from the actor's derived data
            if (defenderActor.system?.derived) {
                const actorArmorWear = defenderActor.system.battleWear?.armor?.value || 0;
                const actorArmorMax = defenderActor.system.derived.armorBonusMax || 4;
                
                // Display max wear as the armor bonus max - current wear
                // For injury card, we want to start at 0 and subtract from max
                battleWearData.defender.maxWear = Math.max(0, actorArmorMax - actorArmorWear);
                battleWearData.defender.armorBonus = defenderActor.system.derived.armorBonusEffective || 0;
                battleWearData.defender.currentWear = 0; // Start at 0 for the injury card
                battleWearData.defender.actualWear = actorArmorWear; // Store the actual wear for reference
            } else {
                // Fallback to finding the actor's equipped armor
            const equippedArmor = defenderActor.items.find(i => 
                i.type === "armor" && 
                i.system.equipped
            );
            
            if (equippedArmor) {
                // Get the armor's soak bonus as max wear
                    const armorBonus = parseInt(equippedArmor.system.soak.bonus) || 4;
                    battleWearData.defender.maxWear = armorBonus;
                    battleWearData.defender.armorBonus = armorBonus;
                battleWearData.defender.armorName = equippedArmor.name;
                }
            }
            
            // Get token image
            if (defenderActor.token) {
                battleWearData.defender.tokenImg = defenderActor.token.img;
            } else if (defenderActor.prototypeToken) {
                battleWearData.defender.tokenImg = defenderActor.prototypeToken.texture.src;
            } else {
                battleWearData.defender.tokenImg = defenderActor.img;
            }
        }
        
        return battleWearData;
    }
    
    /**
     * Create an injury item on the defender
     * @param {Actor} defenderActor The defender actor
     * @param {string} injuryName Name of the injury
     * @param {string} location Hit location
     * @param {number} damage Amount of damage
     * @param {string} injuryEffect Effect of the injury
     * @private
     */
    static async _createInjuryItem(defenderActor, injuryName, location, damage, injuryEffect) {
        // Create a new injury item
        const injuryData = {
            name: injuryName,
            type: "injury",
            img: "icons/svg/blood.svg",
            system: {
                description: `Injury to the ${location} with ${damage} damage.`,
                location: location,
                severity: {
                    value: damage, // Use the exact damage value
                    label: damage < 4 ? "Minor" : damage < 7 ? "Major" : "Severe"
                },
                effect: injuryEffect
            }
        };
        
        // Create the injury on the defender
        await defenderActor.createEmbeddedDocuments("Item", [injuryData]);
    }

    /**
     * Generate a description for an injury based on location and severity
     * @param {string} location The hit location
     * @param {number} severity The severity level
     * @returns {string} A descriptive name for the injury
     * @private
     */
    static _generateInjuryDescription(location, severity) {
        let severityLabel = "Minor";
        if (severity >= 7) {
            severityLabel = "Severe";
        } else if (severity >= 4) {
            severityLabel = "Major";
        } else if (severity === 0) {
            return `Attack Deflected by ${location}`;
        }
        
        return `${severityLabel} ${location} Injury`;
    }
}

/**
 * Create click handlers for all create-injury buttons
 */
function createInjuryButtons() {
    console.log("Setting up create injury button handlers");
    const buttons = document.querySelectorAll('.create-injury');
    console.log(`Found ${buttons.length} create injury buttons`);
    
    buttons.forEach(button => {
        // Remove any existing click handlers
        button.removeEventListener('click', createInjuryHandler);
        
        // Add click handler
        button.addEventListener('click', createInjuryHandler);
    });
}

// Make createInjuryButtons available globally
window.createInjuryButtons = createInjuryButtons;

/**
 * Handler for create injury button clicks
 * @param {Event} event The click event
 */
async function createInjuryHandler(event) {
    event.preventDefault();
    
    // Get the button and message element
    const button = event.currentTarget;
    const messageElement = button.closest('.message');
    
    if (!messageElement) {
        console.error("Could not find message element for create injury button");
        ui.notifications.error("Could not find message element. Please try again.");
        return;
    }
    
    // Get the message ID
    const messageId = messageElement.dataset.messageId;
    if (!messageId) {
        console.error("Could not find message ID");
        ui.notifications.error("Could not find message ID. Please try again.");
        return;
    }
    
    // Get the actual ChatMessage object
    const message = game.messages.get(messageId);
    if (!message) {
        console.error(`Could not find message with ID ${messageId}`);
        ui.notifications.error("Could not find message. Please try again.");
        return;
    }
    
    console.log("Found message for create injury button:", message);
    
    // Get the defender name
    const defenderElement = messageElement.querySelector('.combatant.defender .token-name');
    const defenderName = defenderElement ? defenderElement.textContent.trim() : "Defender";
    
    // Get the damage amount and location
    const damageElement = messageElement.querySelector('.damage-amount');
    const damage = damageElement ? parseInt(damageElement.textContent) || 1 : 1;
    
    const locationElement = messageElement.querySelector('.hit-location');
    const location = locationElement ? locationElement.textContent.trim() : "Torso";
    
    // Get the defender actor
    let defenderActor = null;
    
    // First try to find in tokens
    for (const token of canvas.tokens.placeables) {
        if (token.name === defenderName && token.actor) {
            defenderActor = token.actor;
            console.log(`Found defender token: ${token.name}`);
            break;
        }
    }
    
    // If not found in tokens, try actors directory
    if (!defenderActor) {
        defenderActor = game.actors.find(a => a.name === defenderName);
        console.log(`Found defender in actors directory: ${defenderActor?.name}`);
    }
    
    if (!defenderActor) {
        console.error(`Could not find defender actor: ${defenderName}`);
        ui.notifications.error(`Could not find defender "${defenderName}". Please try again.`);
        return;
    }
    
    try {
        // Get battle wear data from the message
        const attackerWearElement = messageElement.querySelector('.attacker-wear .battle-wear-value');
        const defenderWearElement = messageElement.querySelector('.defender-wear .battle-wear-value');
        
        let attackerWear = 0;
        let defenderWear = 0;
        
        if (attackerWearElement) {
            attackerWear = parseInt(attackerWearElement.textContent) || 0;
        }
        
        if (defenderWearElement) {
            defenderWear = parseInt(defenderWearElement.textContent) || 0;
        }
        
        // Apply battle wear first
        console.log(`Applying battle wear after injury: Attacker ${attackerWear}, Defender ${defenderWear}`);
        await applyBattleWear(message, attackerWear, defenderWear);
        
        // Generate injury name based on location and severity
        const severity = damage > 3 ? "Major" : "Minor";
        const injuryName = `${severity} ${location} Injury`;
        
        // Generate effect based on location and severity
        const injuryEffect = HitLocationSelector._generateInjuryEffect(location, damage);
        
        // Create the injury item
        await HitLocationSelector._createInjuryItem(defenderActor, injuryName, location, damage, injuryEffect);
        
        console.log(`Created injury "${injuryName}" for ${defenderName}`);
        ui.notifications.info(`Injury "${injuryName}" added to ${defenderName}.`);
        
        // Disable the create injury button
        button.disabled = true;
        button.textContent = "Injury Applied";
        button.style.backgroundColor = "#555";
    } catch (error) {
        console.error(`Error creating injury for ${defenderName}:`, error);
        ui.notifications.error(`Error creating injury: ${error.message}`);
    }
}

// Make createInjuryHandler available globally
window.createInjuryHandler = createInjuryHandler;

/**
 * Apply battle wear to the attacker's weapon and defender's armor
 * @param {ChatMessage} message The chat message with battle wear
 * @param {number} attackerWear Amount of battle wear for attacker's weapon
 * @param {number} defenderWear Amount of battle wear for defender's armor
 */
async function applyBattleWear(message, attackerWear, defenderWear) {
    try {
        // Log the battle wear application
    console.log(`Applying battle wear: ${attackerWear} to attacker's weapon, ${defenderWear} to defender's armor`);
        console.log("Message object:", message);
        
        // Input validation
        if (!message) {
            console.warn("No message provided to applyBattleWear");
            ui.notifications.warn("Could not apply battle wear: No message provided");
            return;
        }
        
        // Convert wear values to numbers and ensure they're non-negative
        attackerWear = Math.max(0, parseInt(attackerWear) || 0);
        defenderWear = Math.max(0, parseInt(defenderWear) || 0);
        
        // If both wear values are 0, nothing to do
        if (attackerWear === 0 && defenderWear === 0) {
            console.log("No battle wear to apply");
            return;
        }
        
        // Initialize variables for attacker and defender names
        let attackerName = "Attacker";
        let defenderName = "Defender";
        
        // Try to get the message element
        let messageElement = null;
        
        // First try the message.element property
        if (message.element) {
            messageElement = message.element;
            console.log("Found message element via message.element property");
        }
        // Then try jQuery to find it by message ID
        else if (message.id) {
            const $messageHtml = $(`.message[data-message-id="${message.id}"]`);
            if ($messageHtml.length > 0) {
                messageElement = $messageHtml[0];
                console.log("Found message element via jQuery selector");
            }
        }
        // Last resort - try to parse the content
        else if (message.content) {
            console.log("Trying to get actor names from message content");
            // This will be handled below
        }
        
        // Methods to get actor names - try each until we find one that works
        const methods = [
            // Method 1: From message element selectors
            () => {
                if (!messageElement) return false;
                
                const attackerEl = messageElement.querySelector('.combatant.attacker .token-name');
                const defenderEl = messageElement.querySelector('.combatant.defender .token-name');
                
                if (attackerEl && defenderEl) {
                    attackerName = attackerEl.textContent.trim();
                    defenderName = defenderEl.textContent.trim();
                    console.log(`Found names in message element - Attacker: "${attackerName}", Defender: "${defenderName}"`);
                    return true;
                }
                return false;
            },
            
            // Method 2: From message flags
            () => {
                const messageData = message?.getFlag?.("witch-iron", "injuryData");
                if (messageData) {
                    if (messageData.attacker) attackerName = messageData.attacker;
                    if (messageData.defender) defenderName = messageData.defender;
                    console.log(`Found names in message flags - Attacker: "${attackerName}", Defender: "${defenderName}"`);
                    return true;
                }
                return false;
            },
            
            // Method 3: From jQuery parsing the message content
            () => {
                if (!message.content) return false;
                
                const $content = $(message.content);
                const $attackerName = $content.find('.combatant.attacker .token-name');
                const $defenderName = $content.find('.combatant.defender .token-name');
                
                if ($attackerName.length && $defenderName.length) {
                    attackerName = $attackerName.text().trim();
                    defenderName = $defenderName.text().trim();
                    console.log(`Found names in message content - Attacker: "${attackerName}", Defender: "${defenderName}"`);
                    return true;
                }
                return false;
            },
            
            // Method 4: From regex parsing the raw content
            () => {
                if (!message.content) return false;
                
                // Use regex to try to extract names from HTML content
                const attackerRegex = /class="(?:.*?)attacker(?:.*?)"[\s\S]*?class="token-name"[^>]*>(.*?)</i;
                const defenderRegex = /class="(?:.*?)defender(?:.*?)"[\s\S]*?class="token-name"[^>]*>(.*?)</i;
                
                const attackerMatch = message.content.match(attackerRegex);
                const defenderMatch = message.content.match(defenderRegex);
                
                if (attackerMatch && attackerMatch[1]) attackerName = attackerMatch[1].trim();
                if (defenderMatch && defenderMatch[1]) defenderName = defenderMatch[1].trim();
                
                if (attackerMatch || defenderMatch) {
                    console.log(`Found names via regex - Attacker: "${attackerName}", Defender: "${defenderName}"`);
                    return true;
                }
                return false;
            }
        ];
        
        // Try each method until we find actor names
        let foundNames = false;
        for (const method of methods) {
            foundNames = method();
            if (foundNames) break;
        }
        
        if (!foundNames) {
            console.warn("Could not find actor names, using defaults");
        }
        
        console.log(`Using names - Attacker: "${attackerName}", Defender: "${defenderName}"`);
        
        // Find the attacker and defender actors
        let attackerActor = null;
        let defenderActor = null;
        
        // Function to find an actor by name
        const findActor = (name) => {
            // First check tokens
            let actor = null;
            for (const token of canvas.tokens.placeables) {
                if (token.name === name && token.actor) {
                    actor = token.actor;
                    console.log(`Found actor in tokens: ${token.name}`);
                    break;
                }
            }
            
            // If not found in tokens, check actors directory
            if (!actor) {
                actor = game.actors.find(a => a.name === name);
                if (actor) {
                    console.log(`Found actor in directory: ${actor.name}`);
                }
            }
            
            return actor;
        };
        
        // Find the actors
        attackerActor = findActor(attackerName);
        defenderActor = findActor(defenderName);
        
        if (!attackerActor) {
            console.warn(`Could not find attacker actor: ${attackerName}`);
        }
        if (!defenderActor) {
            console.warn(`Could not find defender actor: ${defenderName}`);
        }
        
        // Apply battle wear to the attacker's weapon
        if (attackerActor && attackerWear > 0) {
            // Get the current battle wear value
            const currentWear = attackerActor.system?.battleWear?.weapon?.value || 0;
            console.log(`Attacker's current weapon wear: ${currentWear}`);
            
            // Calculate max wear value
            const maxWear = attackerActor.system?.derived?.weaponBonusMax || 0;
            console.log(`Attacker's max weapon wear: ${maxWear}`);
            
            // Calculate new battle wear (don't exceed max value)
            const newWear = Math.min(maxWear, Math.max(0, currentWear + attackerWear));
            console.log(`Calculated new wear: ${newWear} (current ${currentWear} + increase ${attackerWear}, max ${maxWear})`);
            
            // Only update if there's an actual change
            if (newWear !== currentWear) {
                try {
                    // Update the actor with the new battle wear value
                    await attackerActor.update({
                        'system.battleWear.weapon.value': newWear
                    });
                    
                    console.log(`Updated attacker's weapon wear to ${newWear}`);
                    ui.notifications.info(`Applied ${attackerWear} battle wear to ${attackerName}'s weapon (${currentWear} â†’ ${newWear})`);
                    
                    // Make sure changes are reflected in UI
                    attackerActor.render(false);
                    if (attackerActor.sheet?.rendered) {
                        attackerActor.sheet.render(true);
                    }
                } catch (error) {
                    console.error("Error updating attacker battle wear:", error);
                    ui.notifications.error(`Error applying battle wear to ${attackerName}: ${error.message}`);
                }
            } else {
                console.log("No change to attacker's weapon wear needed");
            }
        }
        
        // Apply battle wear to the defender's armor
        if (defenderActor && defenderWear > 0) {
            // Get the current battle wear value
            const currentWear = defenderActor.system?.battleWear?.armor?.value || 0;
            console.log(`Defender's current armor wear: ${currentWear}`);
            
            // Calculate max wear value
            const maxWear = defenderActor.system?.derived?.armorBonusMax || 0;
            console.log(`Defender's max armor wear: ${maxWear}`);
            
            // Calculate new battle wear (don't exceed max value)
            const newWear = Math.min(maxWear, Math.max(0, currentWear + defenderWear));
            console.log(`Calculated new wear: ${newWear} (current ${currentWear} + increase ${defenderWear}, max ${maxWear})`);
            
            // Only update if there's an actual change
            if (newWear !== currentWear) {
                try {
                    // Update the actor with the new battle wear value
                    await defenderActor.update({
                        'system.battleWear.armor.value': newWear
                    });
                    
                    console.log(`Updated defender's armor wear to ${newWear}`);
                    ui.notifications.info(`Applied ${defenderWear} battle wear to ${defenderName}'s armor (${currentWear} â†’ ${newWear})`);
                    
                    // Make sure changes are reflected in UI
                    defenderActor.render(false);
                    if (defenderActor.sheet?.rendered) {
                        defenderActor.sheet.render(true);
                    }
                } catch (error) {
                    console.error("Error updating defender battle wear:", error);
                    ui.notifications.error(`Error applying battle wear to ${defenderName}: ${error.message}`);
                }
            } else {
                console.log("No change to defender's armor wear needed");
            }
        }
        
        // Disable the battle wear buttons after applying if we have the message element
    if (messageElement) {
        const battleWearButtons = messageElement.querySelectorAll('.battle-wear-plus, .battle-wear-minus');
        battleWearButtons.forEach(button => {
            button.disabled = true;
        });
            
            console.log(`Disabled ${battleWearButtons.length} battle wear buttons`);
        
        // Hide the create injury button
        const createInjuryButton = messageElement.querySelector('.create-injury');
        if (createInjuryButton) {
            createInjuryButton.style.display = 'none';
                console.log("Hidden create injury button");
            }
        }
        
        return { attackerActor, defenderActor };
    } catch (error) {
        console.error("Error in applyBattleWear:", error);
        ui.notifications.error(`Error applying battle wear: ${error.message}`);
        return null;
    }
}

/**
 * Helper function to refresh an actor's sheet battle wear display
 * @param {Actor} actor The actor whose sheet needs refreshing
 * @return {boolean} Whether the sheet was found and refreshed
 */
function refreshActorSheet(actor) {
    // Check if the actor has an open sheet
    const sheet = actor.sheet;
    console.log(`Refreshing sheet for ${actor.name}:`, sheet);
    
    if (!sheet?.rendered) {
        console.log(`Sheet for ${actor.name} is not rendered, returning false`);
        return false;
    }
    
    // If it's a WitchIronMonsterSheet, call the _updateBattleWearDisplays method
    if (sheet._updateBattleWearDisplays && typeof sheet._updateBattleWearDisplays === 'function') {
        console.log(`Calling _updateBattleWearDisplays for ${actor.name}`);
        console.group(`Updating battle wear displays for ${actor.name}`);
        
        // Add some extra debug logging to the battle wear data
        const weaponWear = actor.system.battleWear?.weapon?.value || 0;
        const armorWear = actor.system.battleWear?.armor?.value || 0;
        console.log(`Current battle wear values - Weapon: ${weaponWear}, Armor: ${armorWear}`);
        console.log(`Actor's full battleWear data:`, actor.system.battleWear);
        
        sheet._updateBattleWearDisplays();
        console.log("Battle wear displays updated successfully");
        console.groupEnd();
        return true;
    } else {
        // If it's not the right sheet type, fully re-render
        console.log(`Sheet doesn't have _updateBattleWearDisplays method, doing full render for ${actor.name}`);
        sheet.render(true);
        return true;
    }
    
    return false;
}

// Helper function to update injury button text
function updateInjuryButtonText(messageElement, defender) {
    if (!messageElement) return;
    
    // Try to get the defender wear value safely
    let defenderWearValue = 0;
    const defenderWearElement = messageElement.querySelector('.defender-wear .battle-wear-value');
    if (defenderWearElement) {
        defenderWearValue = parseInt(defenderWearElement.textContent) || 0;
    }
    
    // Find the injury button with the matching defender
    const injuryButton = messageElement.querySelector(`.create-injury[data-defender="${defender}"]`);
    
    if (injuryButton) {
        if (defenderWearValue > 0) {
            injuryButton.innerHTML = `<i class="fas fa-plus-circle"></i> Roll Battle Wear & Injury for ${defender}`;
        } else {
            injuryButton.innerHTML = `<i class="fas fa-plus-circle"></i> Add Injury to ${defender}`;
        }
    }
}

/**
 * Dialog to select a hit location
 */
export class HitLocationDialog extends Application {
    constructor(data={}, options={}) {
        super(options);
        this.data = data;
        this.selectedLocation = null;
        this.phase = "defender"; // defender or attacker
        this.moveHistory = [];
        this.netHits = data.netHits || 0;
        this.remainingHits = this.netHits;
        
        // Define adjacency map (which locations can be moved between)
        this.adjacencyMap = {
            'head': ['torso'],
            'torso': ['head', 'left-arm', 'right-arm', 'left-leg', 'right-leg'],
            'left-arm': ['torso'],
            'right-arm': ['torso'],
            'left-leg': ['torso'],
            'right-leg': ['torso']
        };
        
        // Movement cost
        this.moveCost = 2;
        
        console.log("HitLocationDialog created with data:", this.data);
    }

    /** @override */
    static get defaultOptions() {
        return foundry.utils.mergeObject(super.defaultOptions, {
            id: "hit-location-dialog",
            title: "Select Hit Location",
            template: "systems/witch-iron/templates/dialogs/hit-location-selector.hbs",
            width: 400,
            height: 600,
            classes: ["witch-iron", "hit-location-dialog"],
            resizable: true
        });
    }
    
    /** @override */
    getData(options={}) {
        return {
            defenderName: this.data.defenderName || "Target",
            damageAmount: this.data.damageAmount || 0,
            netHits: this.netHits
        };
    }

    /**
     * Move to the attacker phase where they can spend net hits to adjust location
     * @param {string} initialLocation The initially selected location
     */
    moveToAttackerPhase(initialLocation) {
        console.log("Moving to attacker phase");
        this.phase = "attacker";
        
        // Hide defender phase elements
        this.element.find('.defender-phase').hide();
        this.element.find('.defender-buttons').hide();
        
        // Show attacker phase elements
        this.element.find('.attacker-phase').show();
        this.element.find('.attacker-buttons').show();
        
        // Update the title to make it clear we're in adjustment phase
        this.element.find('h2').text("Adjust Hit Location");
        
        // Update the selected location display
        const displayLocation = this.formatLocationName(initialLocation);
        this.element.find('#selected-location').text(displayLocation);
        
        // Update remaining net hits
        this.element.find('#net-hits-remaining').text(this.remainingHits);
        
        // Update available move buttons
        this.updateAvailableMoves();
    }
    
    /**
     * Select a hit location in the defender phase
     * @param {string} location The location to select
     */
    selectLocation(location) {
        console.log(`Selecting location: ${location}`);
        
        // Remove selected class from all labels and body parts
        const locationLabels = this.element.find('.location-label');
        locationLabels.removeClass('selected');
        
        const bodyParts = this.element.find('.body-part');
        bodyParts.removeClass('selected available');
        
        // Add selected class to clicked label and body part
        const selectedLabel = this.element.find(`.location-label[data-location="${location}"]`);
        selectedLabel.addClass('selected');
        
        const selectedPart = this.element.find(`.body-part[data-location="${location}"]`);
        selectedPart.addClass('selected');
        
        this.selectedLocation = location;
        
        // Format the location name for display
        const displayLocation = this.formatLocationName(location);
        
        // If we're in defender phase, proceed to attacker phase
        if (this.phase === "defender" && this.netHits > 0) {
            this.moveToAttackerPhase(location);
        } else {
            // If auto-apply is enabled and we're in defender phase without net hits, apply immediately
            if (this.phase === "defender" && this.netHits <= 0 && this.data.autoApply) {
                this.applyHit(location);
            }
        }
        
        console.log(`Location selected: ${displayLocation}`);
    }
    
    /**
     * Update which move buttons are available based on current location and remaining hits
     */
    updateAvailableMoves() {
        if (!this.selectedLocation) return;
        
        // Clear all available indicators
        const bodyParts = this.element.find('.body-part');
        bodyParts.removeClass('available');
        
        // Remove available indicators from labels
        const locationLabels = this.element.find('.location-label');
        locationLabels.removeClass('available');
        
        // Get adjacent locations
        const adjacentLocations = this.adjacencyMap[this.selectedLocation] || [];
        
        // Enable adjacent locations if we have enough hits
        if (this.remainingHits >= this.moveCost) {
            adjacentLocations.forEach(loc => {
                // Highlight available locations on the body
                this.element.find(`.body-part[data-location="${loc}"]`).addClass('available');
                
                // Also highlight the labels
                this.element.find(`.location-label[data-location="${loc}"]`).addClass('available');
            });
        }
        
        // Enable/disable undo button
        const undoButton = this.element.find('.undo-move-btn');
        if (this.moveHistory.length > 0) {
            undoButton.removeAttr('disabled');
        } else {
            undoButton.attr('disabled', true);
        }
    }
    
    /**
     * Move the hit location to a new location
     * @param {string} targetLocation The new location
     */
    moveLocation(targetLocation) {
        if (!this.selectedLocation) return;
        
        // Check if the move is valid
        const adjacentLocations = this.adjacencyMap[this.selectedLocation] || [];
        if (!adjacentLocations.includes(targetLocation) || this.remainingHits < this.moveCost) {
            console.warn(`Invalid move from ${this.selectedLocation} to ${targetLocation}`);
            return;
        }
        
        // Record the move in history for undo
        this.moveHistory.push(this.selectedLocation);
        
        // Update remaining hits
        this.remainingHits -= this.moveCost;
        this.element.find('#net-hits-remaining').text(this.remainingHits);
        
        // Select the new location
        this.selectLocationInAttackerPhase(targetLocation);
    }
    
    /**
     * Select a location during the attacker phase
     * @param {string} location The new location
     */
    selectLocationInAttackerPhase(location) {
        // Remove selected and available classes from all body parts
        const bodyParts = this.element.find('.body-part');
        bodyParts.removeClass('selected available');
        
        // Remove selected from all labels
        const locationLabels = this.element.find('.location-label');
        locationLabels.removeClass('selected');
        
        // Add selected class to the new location elements
        const selectedPart = this.element.find(`.body-part[data-location="${location}"]`);
        selectedPart.addClass('selected');
        
        const selectedLabel = this.element.find(`.location-label[data-location="${location}"]`);
        selectedLabel.addClass('selected');
        
        // Update the selected location
        this.selectedLocation = location;
        
        // Update display
        const displayLocation = this.formatLocationName(location);
        this.element.find('#selected-location').text(displayLocation);
        
        // Update available moves
        this.updateAvailableMoves();
    }
    
    /**
     * Undo the last move
     */
    undoMove() {
        if (this.moveHistory.length === 0) return;
        
        // Get the previous location
        const previousLocation = this.moveHistory.pop();
        
        // Refund the net hits
        this.remainingHits += this.moveCost;
        this.element.find('#net-hits-remaining').text(this.remainingHits);
        
        // Select the previous location
        this.selectLocationInAttackerPhase(previousLocation);
    }
    
    /**
     * Format a location string for display
     * @param {string} location The location to format
     * @returns {string} The formatted location name
     */
    formatLocationName(location) {
        return location.split('-').map(word => 
            word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
    }
    
    /**
     * Apply the hit with the selected location
     * @param {string} location Location to apply the hit to
     */
    applyHit(location) {
        console.log(`Applying hit to location: ${location}`);
        if (this.data.applyHitCallback) {
            // Pass the remaining net hits to the callback
            this.data.applyHitCallback(location, this.remainingHits);
        } else {
            console.warn("No applyHitCallback defined");
        }
        this.close();
    }

    /** @override */
    activateListeners(html) {
        super.activateListeners(html);
        
        console.log("Activating listeners for hit location dialog");
        
        // Location labels for defender phase
        const locationLabels = html.find('.location-label');
        console.log(`Found ${locationLabels.length} location labels`);
        
        locationLabels.on('click', (event) => {
            event.preventDefault();
            const location = event.currentTarget.dataset.location;
            console.log(`Label clicked: ${location}`);
            
            if (this.phase === "defender") {
                // In defender phase, simply select the location
                this.selectLocation(location);
            } else {
                // In attacker phase, try to move to the location if it's available
                const adjacentLocations = this.adjacencyMap[this.selectedLocation] || [];
                if (adjacentLocations.includes(location) && this.remainingHits >= this.moveCost) {
                    this.moveLocation(location);
                }
            }
        });
        
        // Body parts clickable too (both phases)
        const bodyParts = html.find('.body-part');
        bodyParts.on('click', (event) => {
            event.preventDefault();
            const location = event.currentTarget.dataset.location;
            
            if (this.phase === "defender") {
                // In defender phase, simply select the location
                this.selectLocation(location);
            } else {
                // In attacker phase, try to move to the location if it's available
                const adjacentLocations = this.adjacencyMap[this.selectedLocation] || [];
                if (adjacentLocations.includes(location) && this.remainingHits >= this.moveCost) {
                    this.moveLocation(location);
                }
            }
        });
        
        // Undo button for attacker phase
        const undoButton = html.find('.undo-move-btn');
        undoButton.on('click', (event) => {
            event.preventDefault();
            this.undoMove();
        });
        
        // Confirm button for attacker phase
        const confirmButton = html.find('.confirm-location-btn');
        confirmButton.on('click', (event) => {
            event.preventDefault();
            if (this.selectedLocation) {
                this.applyHit(this.selectedLocation);
            }
        });

        // Random hit location button (defender phase)
        const randomButton = html.find('.random-location-btn');
        randomButton.on('click', (event) => {
            event.preventDefault();
            const locations = ['head', 'torso', 'left-arm', 'right-arm', 'left-leg', 'right-leg'];
            const randomIndex = Math.floor(Math.random() * locations.length);
            const randomLocation = locations[randomIndex];
            
            console.log(`Random location selected: ${randomLocation}`);
            this.selectLocation(randomLocation);
        });
        
        // Close buttons
        const closeButtons = html.find('.dialog-button.close');
        closeButtons.on('click', (event) => {
            event.preventDefault();
            console.log("Close button clicked");
            this.close();
        });
    }
    
    /** @override */
    close(options={}) {
        console.log("Closing hit location dialog");
        return super.close(options);
    }
}

/**
 * Update the potential injury display to reflect current battle wear values
 * @param {HTMLElement} cardElement The injury card element
 */
function updatePotentialInjury(cardElement) {
    if (!cardElement) return;
    
    // Get all the necessary elements and values
    const attackerWearElement = cardElement.querySelector('.attacker-wear .battle-wear-value');
    const defenderWearElement = cardElement.querySelector('.defender-wear .battle-wear-value');
    const locationElement = cardElement.querySelector('.hit-location');
    const damageElement = cardElement.querySelector('.damage-amount');
    
    // Extract location for injury type
    const location = locationElement ? locationElement.textContent.trim() : "Torso";
    
    // Get the original damage and combat values
    let damage = damageElement ? parseInt(damageElement.textContent) || 0 : 0;
    
    // Get combat detail values
    const detailItems = cardElement.querySelectorAll('.detail-item');
    let weaponDmg = 0;
    let soak = 0;
    let netHits = 0;
    
    if (detailItems.length >= 3) {
        weaponDmg = parseInt(detailItems[0].querySelector('.value')?.textContent) || 0;
        soak = parseInt(detailItems[1].querySelector('.value')?.textContent) || 0;
        netHits = parseInt(detailItems[2].querySelector('.value')?.textContent) || 0;
    }
    
    // Get battle wear values
    let attackerWear = attackerWearElement ? parseInt(attackerWearElement.textContent) || 0 : 0;
    let defenderWear = defenderWearElement ? parseInt(defenderWearElement.textContent) || 0 : 0;
    
    // Calculate the potential new damage
    // Formula: (Net Hits + Weapon + Attacker Wear) - (Soak + Defender Wear Roll) = Potential Damage
    let minDamage = Math.max(0, (netHits + weaponDmg + attackerWear) - (soak + (defenderWear * 6))); // Worst case (all 6s)
    let maxDamage = Math.max(0, (netHits + weaponDmg + attackerWear) - soak); // Best case (defender rolls all 1s)
    let averageDamage = Math.max(0, (netHits + weaponDmg + attackerWear) - (soak + Math.floor(defenderWear * 3.5))); // Average (3.5 per die)
    
    // Create a new injury description based on the potential damage
    const minSeverity = getPotentialInjurySeverity(minDamage);
    const maxSeverity = getPotentialInjurySeverity(maxDamage);
    const averageSeverity = getPotentialInjurySeverity(averageDamage);
    
    // If no defender wear, the exact damage is known
    const exactDamage = defenderWear === 0 ? maxDamage : averageDamage;
    const exactSeverity = defenderWear === 0 ? maxSeverity : averageSeverity;
    
    // Get the effect based on the expected damage
    const effect = HitLocationSelector._generateInjuryEffect(location.toLowerCase().replace(' ', '-'), exactDamage);
    
    // Update the injury display in the main card area
    updateInjuryDisplay(cardElement, exactDamage, location, effect, exactSeverity);
    
    // Update the button's dataset to reflect the new damage
    const injuryButton = cardElement.querySelector('.create-injury');
    if (injuryButton) {
        // Update the severity attribute to use the calculated damage
        injuryButton.dataset.severity = exactDamage.toString();
        
        // Update the description attribute
        const severityLabel = exactSeverity === "Deflected" ? "Deflected" : `${exactSeverity} ${location} Injury`;
        injuryButton.dataset.description = severityLabel;
        
        // Update the effect attribute
        injuryButton.dataset.effect = effect;
    }
    
    // Add the calculation details to the combat details (hidable) section
    const detailsSection = cardElement.querySelector('.combat-details-content');
    if (detailsSection) {
        // Create or get the battle wear calculation container
        let bwCalcSection = detailsSection.querySelector('.battle-wear-calculations');
        if (!bwCalcSection) {
            bwCalcSection = document.createElement('div');
            bwCalcSection.className = 'battle-wear-calculations';
            detailsSection.appendChild(bwCalcSection);
        }
        
        // Create the content based on battle wear values
        let calcContent = `
            <div class="section-header battle-wear-section">
                <h4>Battle Wear Effects</h4>
            </div>
            <div class="section-content">
                <div class="battle-wear-formula">
                    <span>Formula: (${netHits} net hits + ${weaponDmg} weapon + ${attackerWear} weapon wear) - (${soak} soak`;
        
        if (defenderWear > 0) {
            calcContent += ` + ${defenderWear}d6 armor wear)`;
        } else {
            calcContent += `)`;
        }
        
        calcContent += `</span>
                </div>
        `;
        
        if (defenderWear > 0) {
            calcContent += `
                <div class="damage-range">
                    <div class="range-item">
                        <span class="range-label">Best Case:</span>
                        <span class="range-value">${maxDamage} Damage (${maxSeverity})</span>
                    </div>
                    <div class="range-item">
                        <span class="range-label">Average:</span>
                        <span class="range-value">${averageDamage} Damage (${averageSeverity})</span>
                    </div>
                    <div class="range-item">
                        <span class="range-label">Worst Case:</span>
                        <span class="range-value">${minDamage} Damage (${minSeverity})</span>
                    </div>
                </div>
            `;
        } else {
            calcContent += `
                <div class="damage-exact">
                    <span class="range-label">Final Damage:</span>
                    <span class="range-value">${exactDamage} (${exactSeverity})</span>
                </div>
            `;
        }
        
        calcContent += `</div>`;
        
        // Update the container
        bwCalcSection.innerHTML = calcContent;
    }
}

/**
 * Update the main injury display in the card
 * @param {HTMLElement} cardElement The injury card element
 * @param {number} damage The calculated damage
 * @param {string} location The hit location
 * @param {string} effect The injury effect
 * @param {string} severity The injury severity label
 */
function updateInjuryDisplay(cardElement, damage, location, effect, severityLabel) {
    // Find the injury container or create it if not found
    let injuryContainer = cardElement.querySelector('.injury-container');
    let deflectedMessage = cardElement.querySelector('.deflected-message');
    
    // If we have 0 damage, show deflected
    if (damage <= 0) {
        // Create or show deflected message
        if (!deflectedMessage) {
            if (injuryContainer) {
                // Replace injury container with deflected message
                deflectedMessage = document.createElement('div');
                deflectedMessage.className = 'deflected-message';
                injuryContainer.parentNode.replaceChild(deflectedMessage, injuryContainer);
            } else {
                // Create new deflected message
                deflectedMessage = document.createElement('div');
                deflectedMessage.className = 'deflected-message';
                
                // Find where to insert it
                const injuryButton = cardElement.querySelector('.create-injury');
                if (injuryButton) {
                    injuryButton.parentNode.insertBefore(deflectedMessage, injuryButton);
                } else {
                    const cardContent = cardElement.querySelector('.card-content');
                    if (cardContent) {
                        cardContent.appendChild(deflectedMessage);
                    }
                }
            }
        }
        
        // Update deflected message content
        deflectedMessage.innerHTML = `
            <div class="deflected-text">Deflected!</div>
            <div class="deflected-location">0 Damage to the ${location}</div>
        `;
        
        // Hide injury container if it exists
        if (injuryContainer) {
            injuryContainer.style.display = 'none';
        }
    } else {
        // We have damage, show injury
        if (!injuryContainer) {
            if (deflectedMessage) {
                // Replace deflected with injury container
                injuryContainer = document.createElement('div');
                injuryContainer.className = 'injury-container';
                deflectedMessage.parentNode.replaceChild(injuryContainer, deflectedMessage);
            } else {
                // Create new injury container
                injuryContainer = document.createElement('div');
                injuryContainer.className = 'injury-container';
                
                // Find where to insert it
                const injuryButton = cardElement.querySelector('.create-injury');
                if (injuryButton) {
                    injuryButton.parentNode.insertBefore(injuryContainer, injuryButton);
                } else {
                    const cardContent = cardElement.querySelector('.card-content');
                    if (cardContent) {
                        cardContent.appendChild(injuryContainer);
                    }
                }
            }
        }
        
        // Show injury container
        injuryContainer.style.display = '';
        
        // Update injury content
        injuryContainer.innerHTML = `
            <div class="injury-header">
                <h4>Injury</h4>
            </div>
            <div class="injury-row">
                <div class="severity-col">${damage}</div>
                <div class="location-col">${location}</div>
                <div class="effect-col">${effect}</div>
            </div>
        `;
        
        // Hide deflected message if it exists
        if (deflectedMessage) {
            deflectedMessage.style.display = 'none';
        }
    }
}

/**
 * Get the severity label based on damage value
 * @param {number} damage The damage value
 * @returns {string} The severity label
 */
function getPotentialInjurySeverity(damage) {
    if (damage <= 0) return "Deflected";
    if (damage < 4) return "Minor";
    if (damage < 7) return "Major";
    return "Severe";
}

// Hook into the chat message rendering to add the hit location button functionality
Hooks.on("renderChatMessage", (message, html, data) => {
    // Find all hit location buttons in the message
    const hitLocationButtons = html.find('.choose-hit-location');
    
    // Add event listeners to the buttons
    hitLocationButtons.on('click', event => {
        const button = event.currentTarget;
        const attacker = button.dataset.attacker;
        const defender = button.dataset.defender;
        const damage = parseInt(button.dataset.damage);
        const messageId = button.dataset.messageId || message.id;
        
        // Try to get net hits from the message data
        let netHits = 0;
        
        // First check if it's directly in the dataset
        if (button.dataset.netHits) {
            netHits = parseInt(button.dataset.netHits) || 0;
        } 
        // Then check message flags
        else if (message.getFlag("witch-iron", "quarrelData")?.netHits) {
            netHits = parseInt(message.getFlag("witch-iron", "quarrelData").netHits) || 0;
        } 
        // Or check content for net hits display
        else {
            const netHitsElement = html.find('.net-hits');
            if (netHitsElement.length) {
                const hitsText = netHitsElement.text().trim();
                const hitsMatch = hitsText.match(/([+-]?\d+)/);
                if (hitsMatch) {
                    netHits = parseInt(hitsMatch[1]) || 0;
                }
            }
        }
        
        // Make sure net hits are positive
        netHits = Math.max(0, netHits);
        
        console.log(`Opening hit location dialog with ${netHits} net hits`);
        
        // Open the hit location selector dialog
        HitLocationSelector.openDialog({
            attacker,
            defender,
            damage,
            messageId,
            netHits
        });
    });
    
    // Handle collapsible sections
    const collapsibleHeaders = html.find('.section-header');
    collapsibleHeaders.on('click', event => {
        const header = event.currentTarget;
        const content = header.nextElementSibling;
        
        // Toggle open class on header
        header.classList.toggle('open');
        
        // Toggle hidden class on content
        content.classList.toggle('hidden');
    });
    
    // Find all create-injury buttons in the message
    const createInjuryButtons = html.find('.create-injury');
    
    // Add event listeners to the buttons
    createInjuryButtons.on('click', async event => {
        event.preventDefault();
        const button = event.currentTarget;
        const location = button.dataset.location;
        const severity = parseInt(button.dataset.severity);
        const defender = button.dataset.defender;
        const description = button.dataset.description;
        const effect = button.dataset.effect;
        
        // Get battle wear values directly from the elements
        const messageElement = button.closest('.witch-iron.chat-card');
        
        if (!messageElement) {
            console.error("Could not find parent message element for injury button");
            return;
        }
        
        // Find the ChatMessage object that contains this card
        const messageId = messageElement.closest('.message').dataset.messageId;
        const chatMessage = game.messages.get(messageId);
        
        if (!chatMessage) {
            console.error(`Could not find ChatMessage with ID: ${messageId}`);
            return;
        }
        
        console.log("Found chat message:", chatMessage);
        
        // Safely get attacker wear value
        let attackerWear = 0;
        const attackerWearElement = messageElement.querySelector('.attacker-wear .battle-wear-value');
        if (attackerWearElement) {
            attackerWear = parseInt(attackerWearElement.textContent) || 0;
        } else {
            console.warn("Attacker wear element not found");
        }
        
        // Safely get defender wear value
        let defenderWear = 0;
        const defenderWearElement = messageElement.querySelector('.defender-wear .battle-wear-value');
        if (defenderWearElement) {
            defenderWear = parseInt(defenderWearElement.textContent) || 0;
        } else {
            console.warn("Defender wear element not found");
        }
        
        console.log(`Creating injury with battle wear - Attacker: ${attackerWear}, Defender: ${defenderWear}`);
        
        // Only roll for defender's battle wear if they're using it
        let defenderWearRoll = 0;
        if (defenderWear > 0) {
            // Create dice roll formula and roll it
            const formula = `${defenderWear}d6`;
            const roll = await new Roll(formula).roll({async: true});
            defenderWearRoll = roll.total;
            
            // Display the roll
            roll.toMessage({
                flavor: `${defender}'s Battle Wear Roll (${formula})`,
                speaker: ChatMessage.getSpeaker()
            });
            
            // Display the result in chat
            ui.notifications.info(`${defender}'s Battle Wear roll (${formula}): ${defenderWearRoll}`);
        }
        
        // Find the defender actor to apply the injury to
        let defenderActor = null;
        
        // First look in tokens
        for (const token of canvas.tokens.placeables) {
            if (token.name === defender && token.actor) {
                defenderActor = token.actor;
                break;
            }
        }
        
        // If not found in tokens, look in actors directory
        if (!defenderActor) {
            defenderActor = game.actors.find(a => a.name === defender);
        }
        
        // Calculate final damage with battle wear
        // Original: (Net Hits + Weapon) - Soak = Damage
        // With Battle Wear: (Net Hits + Weapon + Attacker Wear) - (Soak + Defender Wear Roll) = Final Damage
        
        // Get original values from the message
        const detailItems = messageElement.querySelectorAll('.detail-item');
        let soak = 0;
        let netHits = 0;
        let weaponDmg = 0;
        
        // More safely extract these values
        if (detailItems.length >= 3) {
            weaponDmg = parseInt(detailItems[0].querySelector('.value')?.textContent) || 0;
            soak = parseInt(detailItems[1].querySelector('.value')?.textContent) || 0;
            netHits = parseInt(detailItems[2].querySelector('.value')?.textContent) || 0;
        } else {
            console.warn("Could not find detail items with combat values");
        }
        
        console.log(`Combat details - Weapon: ${weaponDmg}, Soak: ${soak}, Net Hits: ${netHits}`);
        
        // Calculate final damage
        const finalDamage = Math.max(0, (netHits + weaponDmg + attackerWear) - (soak + defenderWearRoll));
        console.log(`Final damage calculation: (${netHits} + ${weaponDmg} + ${attackerWear}) - (${soak} + ${defenderWearRoll}) = ${finalDamage}`);
        
        // Only create a battle wear summary if defender is using battle wear
        if (defenderWear > 0) {
            // Create a simplified injury-style battle wear result message
            const battleWearResult = `
                <div class="witch-iron chat-card injury-card">
                    <div class="card-header">
                        <i class="fas ${finalDamage <= 0 ? 'fa-shield-alt' : 'fa-tint'}"></i>
                        <h3>${finalDamage <= 0 ? 'Deflected!' : 'Battle Wear Result'}</h3>
                    </div>
                    <div class="card-content">
                        <div class="battle-wear-note">
                            ${defender}'s Battle Wear absorbed ${defenderWearRoll} Dmg
                        </div>
                        ${finalDamage <= 0 ? `
                        <div class="deflected-message">
                            <div class="deflected-text">Deflected!</div>
                            <div class="deflected-location">0 Damage to the ${location}</div>
                        </div>
                        ` : `
                        <div class="injury-container">
                            <div class="injury-header">
                                <h4>Final Injury</h4>
                            </div>
                            <div class="injury-row">
                                <div class="severity-col">${finalDamage}</div>
                                <div class="location-col">${location}</div>
                                <div class="effect-col">${HitLocationSelector._generateInjuryEffect(location.toLowerCase().replace(' ', '-'), finalDamage)}</div>
                            </div>
                        </div>
                        `}
                    </div>
                </div>
            `;
            
            // Create a chat message with the result
            ChatMessage.create({
                content: battleWearResult,
                speaker: ChatMessage.getSpeaker()
            });
        }
        
        // If we found the defender actor, create an injury item on them with the final damage
        if (defenderActor && game.user.isGM) {
            // Generate injury severity based on final damage
            let injurySeverity = "Minor";
            if (finalDamage >= 7) {
                injurySeverity = "Severe";
            } else if (finalDamage >= 4) {
                injurySeverity = "Major";
            } else if (finalDamage === 0) {
                injurySeverity = "Deflected";
            }
            
            // If deflected, don't create an injury
            if (finalDamage === 0) {
                ui.notifications.info(`${defender} deflected the attack completely!`);
                // Still apply the battle wear even if attack was deflected
                console.log(`Attack deflected but still applying battle wear: Attacker ${attackerWear}, Defender ${defenderWear}`);
                await applyBattleWear(chatMessage, attackerWear, defenderWear);
                return;
            }
            
            // Create a new injury name based on final damage
            const finalInjuryName = `${injurySeverity} ${location} Injury`;
            
            // Generate injury effect based on location and final damage
            const finalEffect = HitLocationSelector._generateInjuryEffect(location.toLowerCase().replace(' ', '-'), finalDamage);
            
            // Create the injury item
            const injuryData = {
                name: finalInjuryName,
                type: "injury",
                img: "icons/svg/blood.svg",
                system: {
                    description: `Injury to the ${location} with ${finalDamage} damage.`,
                    location: location,
                    severity: {
                        value: finalDamage,
                        label: injurySeverity
                    },
                    effect: finalEffect
                }
            };
            
            try {
            // Create the injury on the defender
            await defenderActor.createEmbeddedDocuments("Item", [injuryData]);
            
            // Notify the user
            ui.notifications.info(`Injury "${finalInjuryName}" added to ${defender}.`);
            
            // Apply battle wear to both actors' items
                console.log(`Applying battle wear after injury: Attacker ${attackerWear}, Defender ${defenderWear}`);
                await applyBattleWear(chatMessage, attackerWear, defenderWear);
            } catch (error) {
                console.error("Error creating injury:", error);
                ui.notifications.error(`Error creating injury for ${defender}: ${error.message}`);
            }
        } else if (!game.user.isGM) {
            ui.notifications.warn("Only the GM can add injuries to actors.");
        } else {
            ui.notifications.error(`Actor "${defender}" not found.`);
        }
    });
    
    // Handle battle wear buttons
    const battleWearPlusButtons = html.find('.battle-wear-plus');
    const battleWearMinusButtons = html.find('.battle-wear-minus');
    
    battleWearPlusButtons.on('click', event => {
        event.preventDefault();
        const button = event.currentTarget;
        const actorType = button.dataset.actor; // attacker or defender
        const wearType = button.dataset.type; // weapon or armor
        
        // Get the section
        const section = button.closest('.battle-wear-section');
        const valueElement = section.querySelector('.battle-wear-value');
        const maxElement = section.querySelector('.battle-wear-max');
        const bonusElement = section.querySelector('.battle-wear-bonus');
        
        // Get current values
        let currentValue = parseInt(valueElement.textContent) || 0;
        const maxValue = parseInt(maxElement.textContent) || 4;
        
        // Don't exceed maximum
        if (currentValue < maxValue) {
            // Increment the value
            currentValue++;
            valueElement.textContent = currentValue;
            
            // Update the minus button (enable if value > 0)
            const minusButton = section.querySelector('.battle-wear-minus');
            if (minusButton) {
                minusButton.disabled = currentValue <= 0;
            }
            
            // Disable plus button if we reached max
            button.disabled = currentValue >= maxValue;
            
            // Calculate the new effective bonus
            // The max value shown is already adjusted for current wear on actor
            // so we subtract the current card value from it
            let effectiveBonus = Math.max(0, maxValue - currentValue);
            
            // Update the bonus display
            if (bonusElement) {
                bonusElement.textContent = effectiveBonus;
            }
            
            // Update the injury display with the new potential damage
            updatePotentialInjury(button.closest('.witch-iron.chat-card'));
            
            // Update the injury button text
            if (actorType === "defender") {
                // Find the defender name
                let defender = "";
                const messageElement = button.closest('.witch-iron.chat-card');
                const defenderNameElement = messageElement.querySelector('.combatant.defender .token-name');
                
                if (defenderNameElement && defenderNameElement.textContent) {
                    defender = defenderNameElement.textContent.trim();
                } else {
                    // If we can't find it that way, try to get it from the injury button
                    const injuryButton = messageElement.querySelector('.create-injury');
                    if (injuryButton && injuryButton.dataset.defender) {
                        defender = injuryButton.dataset.defender;
                    } else {
                        // Fallback to a generic name
                        defender = "Target";
                    }
                }
                
                updateInjuryButtonText(messageElement, defender);
            }
        }
    });
    
    battleWearMinusButtons.on('click', event => {
        event.preventDefault();
        const button = event.currentTarget;
        const actorType = button.dataset.actor; // attacker or defender
        const wearType = button.dataset.type; // weapon or armor
        
        // Get the section
        const section = button.closest('.battle-wear-section');
        const valueElement = section.querySelector('.battle-wear-value');
        const maxElement = section.querySelector('.battle-wear-max');
        const bonusElement = section.querySelector('.battle-wear-bonus');
        
        // Get current values
        let currentValue = parseInt(valueElement.textContent) || 0;
        const maxValue = parseInt(maxElement.textContent) || 4;
        
        // Don't go below zero
        if (currentValue > 0) {
            // Decrement the value
            currentValue--;
            valueElement.textContent = currentValue;
            
            // Update the plus button (enable if value < max)
            const plusButton = section.querySelector('.battle-wear-plus');
            if (plusButton) {
                plusButton.disabled = currentValue >= maxValue;
            }
            
            // Disable minus button if we reached 0
            button.disabled = currentValue <= 0;
            
            // Calculate the new effective bonus
            // The max value shown is already adjusted for current wear on actor
            // so we subtract the current card value from it
            let effectiveBonus = Math.max(0, maxValue - currentValue);
            
            // Update the bonus display
            if (bonusElement) {
                bonusElement.textContent = effectiveBonus;
            }
            
            // Update the injury display with the new potential damage
            updatePotentialInjury(button.closest('.witch-iron.chat-card'));
            
            // Update the injury button text
            if (actorType === "defender") {
                // Find the defender name
                let defender = "";
                const messageElement = button.closest('.witch-iron.chat-card');
                const defenderNameElement = messageElement.querySelector('.combatant.defender .token-name');
                
                if (defenderNameElement && defenderNameElement.textContent) {
                    defender = defenderNameElement.textContent.trim();
                } else {
                    // If we can't find it that way, try to get it from the injury button
                    const injuryButton = messageElement.querySelector('.create-injury');
                    if (injuryButton && injuryButton.dataset.defender) {
                        defender = injuryButton.dataset.defender;
                    } else {
                        // Fallback to a generic name
                        defender = "Target";
                    }
                }
                
                updateInjuryButtonText(messageElement, defender);
            }
        }
    });
    
    // Initialize potential injury display for injury cards
    const injuryCards = html.find('.witch-iron.chat-card.injury-card');
    injuryCards.each((i, card) => {
        if (card) {
            // Initialize the potential injury display
            updatePotentialInjury(card);
            
            // Add a data attribute to indicate it's been initialized
            card.dataset.initialized = 'true';
            
            console.log(`Initialized potential injury display for card #${i}`);
        }
    });
    
    // Set up global handlers for create injury buttons
    try {
        // Try to use the global/window version of the function first
        if (typeof window.createInjuryButtons === 'function') {
            window.createInjuryButtons();
        } else {
            console.log("Using local createInjuryButtons function");
            createInjuryButtons();
        }
    } catch (error) {
        console.error("Error setting up injury buttons:", error);
        // Fallback: Manually attach handlers to each button
        const buttons = html.find('.create-injury');
        buttons.each((i, button) => {
            $(button).off('click').on('click', window.createInjuryHandler || function(event) {
                console.log("Fallback handler used for injury button");
                ui.notifications.warn("The injury system encountered an error. Please refresh your browser.");
            });
        });
    }
});
